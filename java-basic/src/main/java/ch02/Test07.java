// 문자 리터
package ch02;

public class Test07 {
   
 public static void main(String[] args) {
    // '가' 문자를 출력하라 
     System.out.println(0xac00);  // UTF-16 코드 값을 지정한다. 
     // 해당 숫자가 UTF-16의 문자 코드 임을 알려주지 않으면 프린트할때 일반 숫자인줄알고 십진수로 출력한다. 
     System.out.println((char)0xac00); 
     // 해결책 -----> 숫자앞에 (char)를 붙여 이숫자가 평범한 숫자가 아니라 utf-16임을 알려줘라 !!
        // utf-16 은 2바이트 크기를 갖는다.  코드의 값은 0~65535이다. [음수가 없다] 
          //참고 숫자 2바이트의 범위는 -32768 ~ 32767 이다.
     
     //문자의 코드를 알지 못한다면 작은 따옴표
     System.out.println('가'); 
     //한글 '가'의 utf-16 값을 리턴한다 또한 이값이 문자의 코드 값임을 알려준다. 
     System.out.println('가' + 2); 
     System.out.println((char)('가' + 2));  // 가는 문자가아니다 코드값을 리턴하라는 거다. 
     
      //  작은 따옴표 안에 직접 유니코드를 표기할수 있다.
     System.out.println('\uac00');
     
     //작은 따옴표 안에 직접 유니코드를 지정하는 경우 
    // --> 특수문자를 출력하고 싶을떄
     // 코드에 해당하는 문자를 콘솔창에 출력할때에는 ----> 콘솔창에서 사용하는 폰트에서 해당 문자를 찾는다.
      // -------------->  즉 사용하는 폰트가 무엇이냐에 따라 출력하는 문자의 모양이 다를수 있다.
     System.out.println('\u32d4'); 
     
    }

}

/*
 문자를 컴퓨터에 저장하는 방법 
  -> 2진수화(인코딩 : encoding) 시켜서 저장한다.
  
  *문자의 2진수 규칙 -> 문자집합(character set) 
  1. ASCII (7bit) 
      - 미국 국가 표준 협회(ANSI)에서 영어 알파벳, 숫자, 특수 문자 등을 컴퓨터에서 저장할 수 있도록 2진수로 정의한 인코딩 규칙
        ex) A(0x41), B(0x42) ...LF(0x0a), !(0x21), %(0x25) - 이런문자들을 7bit로 정의한 인코딩 규칙 
      -참고-  윈도우 os에서는 LFCR 두 바이트를 사용하여 줄 바꿈을 표시한다. (윈도우는 컴퓨터이전 타자기의 엔터에서 따왔기 때문에 !!)
             macos, linux는 LF 1바이트만 사용하여 줄 바꿈을 표현한다.  
   
   
   2. ISO-8859-1(ISO-latin-1)   -현제 실제사용 중 
       ASCII을포함하여 유럽문자 까지 포함하는 국제 표현 문자 인코딩 규칙
       가장 널리 쓰이며 대부분의 서유럽 언어를 지원한다. 네덜란드어(일부[* 1]), 
       노르웨이어, 덴마크어, 독일어, 로만슈어, 스웨덴어 스코틀랜드 게일어, 아이슬란드어, 아일랜드어, 에스파냐어, 영어, 이탈리아어, 페로어, 포르투갈어, 
       프랑스어(일부[* 2]), 핀란드어(일부[* 2]), 동유럽의 알바니아어, 아프라카의 스와힐리어, 아프리칸스어. 유로 기호(€)와 대문자 "Ÿ"는 개정판인 ISO 8859-15에 
       추가되었다. IANA의 문자 집합 ISO-8859-1에 대응하며, HTML 문서의 기본 인코딩이다.  
       
    3. EUC-KR(2btye 한글 2560자 + 한자 등 포함)
       한글 음절 한 개에 대해 인코딩 규칙을 정의한 완성형 인코딩 규칙
       현재 유통되는 모든 한글 음절을 표현할수 없다. 
       가(0xb0a1), 각(0xb0a2, 똘(0xb6ca), 똠(?), 똥(0xb6cb)   이렇게 똠이 표현이 안되있다.
       
       4. 조합형(2btye 한글 (1비트)   초성(5비트)   중성(5)    종성 (5))
       국제 표준이 아니다!!!
       -초성 : ㄱ(00010), ㄲ(00011), ㄴ(00100) ....5비트
       -중성 : ㅏ(00011), ㅐ(00100), ㅑ(00101) ......5비트
       -종성 : ㄱ(00010), ㄲ(00011), ㄳ(00100), ㄴ(00101) 5비트
       
         ex) 꺅 (1000 1100 1010 0010) = 0x8ca2
         
       5. MS949(CP949 : 2byte)
        - 윈도우 os의 인코딩 규칙이다.
       euc-kr + 현재유통되는 한글음절 추가 = MS949(11172자 + 한국 전용한자 + 옛한글 등)
       ex) 똠(0x8c63), 똡(0x8c64), 등등 ....
       
       *기존의 euc-kr에 문자를 추가했기 때문에 정렬할 때 문제가 발생한다. 
       ex) "똘똠똡똥" (b6ca 8c63 8c64 b6cb) 문자를 정렬한다면 숫자 크기에 따라 
              똠똡똘똥 순으로 나열될것이다. (덮어씌우다보니 이미 쓰고있던 수들은 어쩔수없이 두고 뒤에 생성하다보니 발생했다.)
              
        6. unicode (2바이트 : UTF-16 = ISO 10646)
         국제표준 인코딩 규칙이다. 
         영어/ 한글 모두 2바이트로 인코딩 
         MS949의 모든 문자가 포함되어 있다. BUT 규칙은 다르다.(저 두놈은 국제표준이 아니므로) 
         -A(0x0041), B(0x0042) ......가(0xac00)
         기존의 EUC-KR과 MS949코드와 호환되지 않는다. (저 두놈은 국제표준이 아니므로)
         - 자바 JVM은 내부에서 문자열을 다룰 때 UTF-16을 사용한다.  즉, 영어 한글 모두 2바이트 유니코드로 다룬다. 
         
         
         7. UTF-8(1~4바이트 : Unicode 변경 형식)
           unicode 에서 영어권 문자를 그대로 1바이트로 인코딩하기 위해 탄생함
            unicode(UTF16)을 그대로 사용하면, 기존의 OS를 모두 변경해야 한다. 
            OS 는 ISO-8859-1 규칙에 따라 영어를 다루기 때문에
              한/중/일 처럼 2바이트를 사용하는 문자를 다루기 위해 전세계의 모든 컴퓨터의 운영체제를 
              빠꾸기에는 너무 무리가 있어서 영어권 PC는 unicode 를 사용하더라도 변경할 필요가 없도록 UTF-8을 만들었다. 
              
              규칙 0000~007f(7bit ASCII) 이건 전과 같이 1바이트로 인코딩 
                  0080~07ff : 2바이트로 인코딩
                    0800~ffff : 3바이트로 인코딩
                    한글 (ac00 ~ d7af) 0800~ffff에 속하기 때문에 3바이트로 변환해야함 
                    UTF-16 가(ac00) 을 utf-8로 인코딩하기
                    가 1010 1100 0000 0000  utf16  ----> 1110 1010 1011 0000 1000 0000 utf 8  ---------> 0xEAB080 (바뀐것)
         
         
       
        
         
  
  
  
  
  
  
  
 */
